<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    
    <title>Audio Visualizer</title>
  </head>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

#container {
    position: absolute;
    top: 0;
    left: 0;
    background: #000;
    width: 100%;
    height: 100%;
}

#canvas {
    position:absolute;
    top: 10px;
    left: 10px;
    width: 95%;
    height:95%;
    background-image:url(tulip73.webp);
    background-repeat:no-repeat;
    background-position: left 15% bottom 3%;
}

#canvas_back {
    position:fixed;
    top: 10px;
    left:10px;
    width:1300px;
    height:800px;
    clip-path:url(#Clip2);
    background-image:url(blossom.gif);
    background-repeat:repeat;
    background-position: left 5% bottom 0%;
}

div {
  background-color: aqua;
}
audio {
   position:absolute;
   display:inline-block;
   height:-50px
}
</style>
<svg id="svg2"  >
  <clipPath id="Clip2" >
  
    <path transform="scale(1.3,1.6) translate(10,30)" d="M168.477989,12.8772838 C195.531935,41.6197637 200.481172,150.575034 177.63799,174.665833 C139.547341,214.836864 58.1415734,203.18878 24.7427758,167.953683 C-7.38084372,134.063875 -7.95449956,85.0861283 21.4459247,38.6567367 C44.4976571,2.25325144 144.20531,-12.9103404 168.477989,12.8772838 Z"></path>
    <path transform="scale(2.3,1.6) translate(280,210)" d="M168.477989,12.8772838 C195.531935,41.6197637 200.481172,150.575034 177.63799,174.665833 C139.547341,214.836864 58.1415734,203.18878 24.7427758,167.953683 C-7.38084372,134.063875 -7.95449956,85.0861283 21.4459247,38.6567367 C44.4976571,2.25325144 144.20531,-12.9103404 168.477989,12.8772838 Z"></path>
    
  </clipPath>
  
  <clipPath id="svgClip" clipPathUnits="objectBoundingBox">
    <path  transform="scale(.95,.95) translate(0,.15)" d="M0.5,1
    C 0.5,1,0,0.7,0,0.3
    A 0.25,0.25,1,1,1,1,0.3
    C 1,0.7,0.5,1,0.5,1 Z">
   

</svg>
  <body>
    <div id="container" >
      
      <canvas id="canvas_back"></canvas>
      <canvas id="canvas"></canvas>
      <audio id="audio" controls ></audio>
      
    

    <script >
       
      var audio1 = document.getElementById('audio');
       audio1.src = "./Chopin.mp3";

      const container = document.getElementById("container");
      
       

        
        var audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let audioSource = null;
        let analyser = null;

        //audio1.play();
        audioSource = audioCtx.createMediaElementSource(audio1);
        analyser = audioCtx.createAnalyser();
        audioSource.connect(analyser);
        analyser.connect(audioCtx.destination);

        analyser.fftSize = 256;
const bufferLength = analyser.frequencyBinCount;
var   dataArray = new Uint8Array(bufferLength);
var barWidth =1.5;
var barHeight;

       
       
canvas1=document.getElementById("canvas")  

const ctx1 = canvas1.getContext("2d");
canvas1.width = window.innerWidth; 
canvas1.height = window.innerHeight;

// click function to reseed random tree
canvas1.addEventListener("click",()=> {
      treeSeed = Math.random() * 10000 | 0;
      treeGrow = 0.4; // regrow tree
});

/* Seeded random functions
   randSeed(int)  int is a seed value
   randSI()  random integer 0 or 1
   randSI(max) random integer from  0 <= random < max
   randSI(min, max) random integer from min <= random < max
   randS()  like Math.random
   randS(max) random float 0 <= random < max
   randS(min, max) random float min <= random < max*/
   
   
const seededRandom = (() => {
    var seed = 1;
    return { max : 2576436549074795, reseed (s) { seed = s }, random ()  { return seed = ((8765432352450986 * seed) + 8507698654323524) % this.max }}
})();
const randSeed = (seed) => seededRandom.reseed(seed|0);
const randSI = (min = 2, max = min + (min = 0)) => (seededRandom.random() % (max - min)) + min;
const randS  = (min = 1, max = min + (min = 0)) => (seededRandom.random() / seededRandom.max) * (max - min) + min;


/* TREE CONSTANTS all angles in radians and lengths/widths are in pixels */
const angMin = 0.01;  // branching angle min and max
const angMax= 0.6;
const lengMin = .8;  // length reduction per branch min and max
const lengMax = .9;
const widthMin = .6; // width reduction per branch min max
const widthMax = .9;
const trunkMin = 6;  // trunk base width ,min and max
const trunkMax = 7;
const maxBranches = 220; // max number of branches


const windX = -1;   // wind direction vector
const windY = 0;
const bendability = 8; // greater than 1. The bigger this number the more the thin branches will bend first

// the canvas2 height you are scaling up or down to a different sized canvas2
const windStrength = 0.015 * bendability * ((200 ** 2) / (canvas1.height ** 2));  // wind strength


// The wind is used to simulate branch spring back the following
// two number control that. Note that the sum on the two following should
// be below 1 or the function will oscillate out of control
const windBendRectSpeed = 0.01;  // how fast the tree reacts to the wing
const windBranchSpring = 0.98;   // the amount and speed of the branch spring back

const gustProbability =.01// how often there is a gust of wind

// Values trying to have a gusty wind effect
var windCycle = 0;
var windCycleGust = 0;
var windCycleGustTime = 0;
var currentWind = 0;
var windFollow = 0;
var windActual = 0;


// The seed value for the tree
var treeSeed = Math.random() * 10000 | 0;

// Vars to build tree with
var branchCount = 0;
var maxTrunk = 0;
var treeGrow = 0.03; // this value should not be zero

// Starts a new tree
function drawTree(seed) {
    branchCount = 0;
    treeGrow += 0.02;
    randSeed(seed);
    maxTrunk = randSI(trunkMin, trunkMax);
    ctx1.strokeStyle='brown'
    drawBranch(canvas1.width*.45, 1.5*canvas1.height, -Math.PI*.5, canvas1.height*.14, maxTrunk);
}

// Recusive tree
function drawBranch(x, y, dir, leng, width) {
    
    branchCount ++;
    const treeGrowVal = (treeGrow > 1.5? 1.5 : treeGrow < 0.1 ? 0.1 : treeGrow) ** 2 ;
    
    // get wind bending force and turn branch direction
    const xx = Math.cos(dir) * leng * treeGrowVal;
    const yy = Math.sin(dir) * leng * treeGrowVal;
    const windSideWayForce = windX * yy - windY * xx;
    
    // change direction by addition based on the wind and scale to 
    // (windStrength * windActual) the wind force
    // ((1 - width / maxTrunk) ** bendability)  the amount of ben3ing due to branch thickness
    // windSideWayForce the force depending on the branch angle to the wind
    dir += (windStrength * windActual) * ((1 - width / maxTrunk) ** bendability) * windSideWayForce;
    var hue=(2*dataArray[10]+260)%330
    //console.log(hue)
    ctx1.strokeStyle='hsl('+ hue + ',90%,35%)';
    ctx1.lineWidth = width*3.8;
    ctx1.beginPath();
    ctx1.lineTo(x, y);
    x += Math.cos(dir) * leng * treeGrowVal;
    y += Math.sin(dir) * leng * treeGrowVal;
    ctx1.lineTo(x, y);
    ctx1.stroke();
    const fontSize=dataArray[1]*.35
          ctx1.font=fontSize+"px Helvitica"
        if ((branchCount < (maxBranches-60) && branchCount>19) && branchCount%5==0) {
           ctx1.strokeText('\u{1F338}', x-20, y)
        }

// if not to thing, not to short and not to many
    if (branchCount < maxBranches && leng > 6 && width > 1) {
        // to stop recusive bias (due to branch count limit)
        // random select direction of first recusive bend
        const rDir = randSI() ? -1 : 1;

        treeGrow -= 0.2;
        drawBranch(
            x,y,
            dir + randS(angMin, angMax) * rDir, 
            leng * randS(lengMin, lengMax), 
            width * randS(widthMin, widthMax)
        );
        // bend next branch the other way
        drawBranch(
            x,y,
            dir + randS(angMin, angMax) * -rDir, 
            leng * randS(lengMin, lengMax), 
            width * randS(widthMin, widthMax)
        );
        treeGrow += 0.2;
    }
}

// Dont ask this is a quick try at wind gusts 
// Wind needs a spacial component this sim does not include that.

function updateWind() {
 
    if (Math.random() <.01) {
        windCycleGustTime = (Math.random() * 40 + 1) | 0;
    }
    if (windCycleGustTime > 0) {
        windCycleGustTime -=2;
        windCycleGust += windCycleGustTime/20
    } else {
        windCycleGust *= 0.98;
    }        
    windCycle += windCycleGust;
    currentWind = (Math.sin(windCycle/40) * 0.4 + .1*Math.sin(windCycle/40)*(dataArray[Math.floor(Math.random()*5)%4]));
    currentWind = currentWind < 0 ? 0 : currentWind;
    windFollow += (currentWind - windActual) * windBendRectSpeed;
    windFollow *= windBranchSpring ;
    windActual += windFollow;
}
var adj=0;

requestAnimationFrame(update);
function update() {
  if (adj%2==0) {
    
    ctx1.clearRect(0,0,canvas1.width,canvas1.height);
    analyser.getByteFrequencyData(dataArray);
    updateWind();
    drawTree(treeSeed);
    adj=0;
  }
    requestAnimationFrame(update);
   adj++;
}

function fulDisplay() {
  var eml=document.documentElement;
  eml.requestFullscreen() || eml.webkitRequestFullscreen();
  console.log("implemented")
}


 window.addEventListener('click', ()=>{
   audioCtx.resume()
  var eml=document.documentElement;
   if (eml.requestFullscreen) {
    eml.requestFullscreen();
  }
  else if (eml.webkitRequestFullscreen) {
    eml.webkitRequestFullscreen()
  }

})
       </script>
      </div>  
  </body>
</html>



















































































































  